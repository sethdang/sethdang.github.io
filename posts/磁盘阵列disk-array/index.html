<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>磁盘阵列(Disk Array) | Seth Dang'S</title><meta name=keywords content><meta name=description content="**
1.为什么需要磁盘阵列
如何增加磁盘的存取(access)速度,如何防止数据因磁盘的故障而失落及如何有效的利用磁盘空间,一直是电脑专业人员和用户的困扰;而大容量磁盘的价格非常昂贵,对用户形成很大的负担。磁盘阵列技术的产生一举解决了这些问题。"><meta name=author content="Seth"><link rel=canonical href=https://seth.dpdns.org/posts/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97disk-array/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://seth.dpdns.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://seth.dpdns.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://seth.dpdns.org/favicon-32x32.png><link rel=apple-touch-icon href=https://seth.dpdns.org/apple-touch-icon.png><link rel=mask-icon href=https://seth.dpdns.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://seth.dpdns.org/posts/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97disk-array/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://seth.dpdns.org/posts/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97disk-array/"><meta property="og:site_name" content="Seth Dang'S"><meta property="og:title" content="磁盘阵列(Disk Array) "><meta property="og:description" content="**
1.为什么需要磁盘阵列
如何增加磁盘的存取(access)速度,如何防止数据因磁盘的故障而失落及如何有效的利用磁盘空间,一直是电脑专业人员和用户的困扰;而大容量磁盘的价格非常昂贵,对用户形成很大的负担。磁盘阵列技术的产生一举解决了这些问题。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2007-03-28T13:53:16+08:00"><meta property="article:modified_time" content="2007-03-28T13:53:16+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="磁盘阵列(Disk Array) "><meta name=twitter:description content="**
1.为什么需要磁盘阵列
如何增加磁盘的存取(access)速度,如何防止数据因磁盘的故障而失落及如何有效的利用磁盘空间,一直是电脑专业人员和用户的困扰;而大容量磁盘的价格非常昂贵,对用户形成很大的负担。磁盘阵列技术的产生一举解决了这些问题。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://seth.dpdns.org/posts/"},{"@type":"ListItem","position":2,"name":"磁盘阵列(Disk Array) ","item":"https://seth.dpdns.org/posts/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97disk-array/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"磁盘阵列(Disk Array) ","name":"磁盘阵列(Disk Array) ","description":"**\n1.为什么需要磁盘阵列\n如何增加磁盘的存取(access)速度,如何防止数据因磁盘的故障而失落及如何有效的利用磁盘空间,一直是电脑专业人员和用户的困扰;而大容量磁盘的价格非常昂贵,对用户形成很大的负担。磁盘阵列技术的产生一举解决了这些问题。\n","keywords":[],"articleBody":"**\n1.为什么需要磁盘阵列\n如何增加磁盘的存取(access)速度,如何防止数据因磁盘的故障而失落及如何有效的利用磁盘空间,一直是电脑专业人员和用户的困扰;而大容量磁盘的价格非常昂贵,对用户形成很大的负担。磁盘阵列技术的产生一举解决了这些问题。\n过去十年来,CPU的处理速度增加了五十倍有多,内存(memory)的存取速度亦大幅增加,而数据储存装置–主要是磁盘(hard disk)–的存取速度只增加了三、四倍,形成电脑系统的瓶颈,拉低了电脑系统的整体性能(throughput),若不能有效的提升磁盘的存取速度,CPU、内存及磁盘间的不平衡将使CPU及内存的改进形成浪费。\n目前改进磁盘存取速度的的方式主要有两种。一是磁盘快取控制(disk cache controller),它将从磁盘读取的数据存在快取内存(cache memory)中以减少磁盘存取的次数,数据的读写都在快取内存中进行,大幅增加存取的速度,如要读取的数据不在快取内存中,或要写数据到磁盘时,才做磁盘的存取动作。这种方式在单工环境(single-tasking environment)如DOS之下,对大量数据的存取有很好的性能(量小且频繁的存取则不然),但在多工(multi-tasking)环境之下(因为要不停的作数据交换(swapping)的动作)或数据库(database)的存取(因为每一记录都很小)就不能显示其性能。这种方式没有任何安全保障。其二是使用磁盘阵列的技术。磁盘阵列是把多个磁盘组成一个阵列,当作单一磁盘使用,它将数据以分段(striping)的方式储存在不同的磁盘中,存取数据时,阵列中的相关磁盘一起动作,大幅减低数据的存取时间,同时有更佳的空间利用率。磁盘阵列所利用的不同的技术,称为RAID level,不同的level针对不同的系统及应用,以解决数据安全的问题。\n一般高性能的磁盘阵列都是以硬件的形式来达成,进一步的把磁盘快取控制及磁盘阵列结合在一个控制器(RAID controller)或控制卡上,针对不同的用户解决人们对磁盘输出入系统的四大要求:\n(1)增加存取速度,\n(2)容错(fault tolerance),即安全性\n(3)有效的利用磁盘空间;\n(4)尽量的平衡CPU,内存及磁盘的性能差异,提高电脑的整体工作性能。\n2.磁盘阵列原理\n磁盘阵列中针对不同的应用使用的不同技术,称为RAID level, RAID是Redundant Array of Inexpensive Disks的缩写,而每一level代表一种技术,目前业界公认的标准是RAID 0~RAID 5。这个level并不代表技术的高低,level 5并不高于level 3,level 1也不低过level 4,至于要选择那一种RAID level的产品,纯视用户的操作环境(operating environment)及应用(application)而定,与level的高低没有必然的关系。RAID 0及RAID 1适用于PC及PC相关的系统如小型的网络服务器(network server)及需要高磁盘容量与快速磁盘存取的工作站等,因为比较便宜,但因一般人对磁盘阵列不了解,没有看到磁盘阵列对他们价值,市场尚未打开;RAID 2及RAID 3适用于大型电脑及影像、CAD/CAM等处理;RAID 5多用于OLTP,因有金融机构及大型数据处理中心的迫切需要,故使用较多而较有名气,但也因此形成很多人对磁盘阵列的误解,以为磁盘阵列非要RAID 5不可;RAID 4较少使用,因为两者有其共同之处,而RAID 4有其先天的限制。其他如RAID 6,RAID 7,乃至RAID 10等,都是厂商各做各的,并无一致的标准,在此不作说明。介绍各个RAID level之前,先看看形成磁盘阵列的两个基本技术:\n译为磁盘延伸,能确切的表示disk spanning这种技术的含义。如下图所示,DFTraid 磁盘阵列控制器,联接了四个磁盘:\n这四个磁盘形成一个阵列(array),而磁盘阵列的控制器(RAID controller)是将此四个磁盘视为单一的磁盘,如DOS环境下的C:盘。这是disk spanning的意义,因为把小容量的磁盘延伸为大容量的单一磁盘,用户不必规划数据在各磁盘的分布,而且提高了磁盘空间的使用率。DFTraid的SCSI磁盘阵列更可连接几十个磁盘，形成数十GB到数百GB的阵列,使磁盘容量几乎可作无限的延伸;而各个磁盘一起作取存的动作,比单一磁盘更为快捷。很明显的,有此阵列的形成而产生RAID的各种技术。我们也可从上图看出inexpensive(便宜)的意义,因为四个250MBbytes的磁盘比一个1GBytes的磁盘要便宜,尤其以前大磁盘的价格非常昴贵,但在磁盘越来越便宜的今天,inexpensive已非磁盘阵列的重点,虽然对于需要大磁盘容量的系统,仍是考虑的要点。\n磁盘 因为磁盘阵列是将同一阵列的多个磁盘视为单一的虚拟磁盘(virtual disk),所以其数据是以分段(block or segment)的方式顺序存放在磁盘阵列中,如下图:\n磁盘0 磁盘1 磁盘2 磁盘3 A0-A1 B0-B1\nC0-C1\nD0-D1\n| | A2-A3 B2-B3\nC2-C3\nD2-D3\n| | A4-A5 B4-B5\nC4-C5\nD4-C5\n| | A6-A7 B6-B7\nC6-C7\nD6-D7\n数据按需要分段,从第一个磁盘开始放,放到最後一个磁盘再回到第一个磁盘放起,直到数据分布完毕。至于分段的大小视系统而定,有的系统或以1KB最有效率,或以4KB,或以6KB,甚至是4MB或8MB的,但除非数据小于一个扇区(sector,即521bytes),否则其分段应是512byte的倍数。因为磁盘的读写是以一个扇区为单位,若数据小于512bytes,系统读取该扇区后,还要做组合或分组(视读或写而定)的动作,浪费时间。从上图我们可以看出,数据以分段于在不同的磁盘,整个阵列的各个磁盘可同时作读写,故数据分段使数据的存取有最好的效率,理论上本来读一个包含四个分段的数据所需要的时间约=(磁盘的access time +数据的transfer time)X4次,现在只要一次就可以完成。\n若以N表示磁盘的数目,R表示读取,W表示写入,S表示可使用空间,则数据分段的性能为:\nR:N(可同时读取所有磁盘)\nW:N(可同时写入所有磁盘)\nS:N(可利用所有的磁盘,并有最佳的使用率)\nDisk striping也称为RAID 0,很多人以为RAID 0没有甚么,其实这是非常错误的观念,因为RAID 0使磁盘的输出入有最高的效率。而磁盘阵列有更好效率的原因除数据分段外,它可以同时执行多个输出入的要求,因为阵列中的每一个磁盘都能独立动作,分段放在不同的磁盘,不同的磁盘可同时作读写,而且能在快取内存及磁盘作并行存取(parallel access)的动作,但只有硬件的磁盘阵列才有此性能表现。\n从上面两点我们可以看出,disk spanning定义了RAID的基本形式,提供了一个便宜、灵活、高性能的系统结构,而disk striping解决了数据的存取效率和磁盘的利用率问题,RAID 1至RAID 5是在此基础上提供磁盘安全的方案。\nRAID 1\nRAID 1是使用磁盘镜像(disk mirroring)的技术。磁盘镜像应用在RAID 1之前就在很多系统中使用,它的方式是在工作磁盘(working disk)之外再加一额外的备份磁盘(backup disk),两个磁盘所储存的数据完全一样,数据写入工作磁盘的同时亦写入备份磁盘。磁盘镜像不见得就是RAID 1,如Novell NetWare亦有提供磁盘镜像的功能,但并不表示NetWare有了RAID 1的功能。一般磁盘镜像和RAID 1有二点最大的不同:\nRAID 1无工作磁盘和备份磁盘之分,多个磁盘可同时动作而有重叠(overlapping)读取的功能,甚至不同的镜像磁盘可同时作写入的动作,这是一种最佳化的方式,称为负载平衡(load-balance)。例如有多个用户在同一时间要读取数据,系统能同时驱动互相镜像的磁盘,同时读取数据,以减轻系统的负载,增加I/O的性能。\nRAID 1的磁盘是以磁盘延伸的方式形成阵列,而数据是以数据分段的方式作储存,因而在读取时,它几乎和RAID 0有同样的性能。从RAID的结构就可以很清楚的看出RAID 1和一般磁盘镜像的不同。\n下图为RAID 1,每一笔数据都储存两份\n磁盘0 磁盘1 磁盘0 磁盘1 A0 A2\nA4\nB1\n| | A1 A3\nB0\nB2\n| | A0 A2\nA4\nB1\n| | A1 A3\nB0\nB2\n从上图可以看出:\nR:N(可同时读取所有磁盘)\nW:N/2(同时写入磁盘数)\nS:N/2(利用率)\n读取数据时可用到所有的磁盘,充分发挥数据分段的优点;写入数据时,因为有备份,所以要写入两个磁盘,其效率是N/2,磁盘空间的使用率也只有全部磁盘的一半。\n很多人以为RAID 1要加一个额外的磁盘,形成浪费而不看好RAID 1,事实上磁盘越来越便宜,并不见得造成负担,况且RAID 1有最好的容错(fault tolerance)能力,其效率也是除RAID 0之外最好的。我们可视应用的不同,在同一磁盘阵列中使用不同的RAID level,如华艺科技公司的DFTraid系列都可同一磁盘阵列中定义八个逻辑磁盘(logic disk),分别使用不同的RAID level,分为C:,D:及E:三个逻辑磁盘(或LUN0,LUN1,LUN2).\nRAID 1完全做到了容错包括不停机(non-stop),当某一磁盘发生故障,可将此磁盘拆下来而不影向其他磁盘的操作;待新的磁盘换上去之后,系统即时做镜像,将数据重新复上去,RAID 1在容错及存取的性能上是所有RAID level之冠。\n在磁盘阵列的技术上,从RAID 1到RAID 5,不停机的意思表示在工作时如发生磁盘故障,系统能持续工作而不停顿,仍然可作磁盘的存取,正常的读写数据;而容错则表示即使磁盘故障,数据仍能保持完整,可让系统存取到正确的数据,而SCSI的磁盘阵列更可在工作中抽换磁盘,并可自动重建故障磁盘的数据。磁盘阵列之所以能做到容错及不停机,是因为它有冗余的磁盘空间可资利用,这也就是Redundant的意义。\nRAID 2\nRAID 2是把数据分散为位元(bit)或块(block),加入海明码Hamming Code,在磁盘阵列中作间隔写入(interleaving)到每个磁盘中,而且地址(address)都一样,也就是在各个磁盘中,其数据都在相同的磁道(cylinder or track)及扇区中。RAID 2的设计是使用共轴同步(spindle synchronize)的技术,存取数据时,整个磁盘阵列一起动作,在各作磁盘的相同位置作平行存取,所以有最好的存取时间(access time),其总线(bus)是特别的设计,以大带宽(band wide)并行传输所存取的数据,所以有最好的传输时间(transfer time)。在大型档案的存取应用,RAID 2有最好的性能,但如果档案太小,会将其性能拉下来,因为磁盘的存取是以扇区为单位,而RAID 2的存取是所有磁盘平行动作,而且是作单位元的存取,故小于一个扇区的数据量会使其性能大打折扣。RAID 2是设计给需要连续且大量数据的电脑使用的,如大型电脑(mainframe to supercomputer)、作影像处理或CAD/CAM的工作站(workstation)等,并不适用于一般的多用户环境、网络服务器(network server),小型机或PC。\nRAID 2的安全采用内存阵列(memory array)的技术,使用多个额外的磁盘作单位错误校正(single-bit correction)及双位错误检测(double-bit detection);至于需要多少个额外的磁盘,则视其所采用的方法及结构而定,例如八个数据磁盘的阵列可能需要三个额外的磁盘,有三十二个数据磁盘的高档阵列可能需要七个额外的磁盘。\nRAID 3\nRAID 3的数据储存及存取方式都和RAID 2一样,但在安全方面以奇偶校验(parity check)取代海明码做错误校正及检测,所以只需要一个额外的校检磁盘(parity disk)。奇偶校验值的计算是以各个磁盘的相对应位作XOR的逻辑运算,然后将结果写入奇偶校验磁盘,任何数据的修改都要做奇偶校验计算,如下图:\n磁盘0 磁盘1 磁盘2 磁盘3 磁盘4 A0 A4\nB3\nC2\n| | A1 B0\nB4\nC3\n| | A2 A1\nC0\nC4\n| | A3 A2\nC1\nD0\n| | P P\nP\nP\n如某一磁盘故障,换上新的磁盘后,整个磁盘阵列(包括奇偶校验磁盘)需重新计算一次,将故障磁盘的数据恢复并写入新磁盘中;如奇偶校验磁盘故障,则重新计算奇偶校验值,以达容错的要求.\n较之RAID 1及RAID 2,RAID 3有85%的磁盘空间利用率,其性能比RAID 2稍差,因为要做奇偶校验计算;共轴同步的平行存取在读档案时有很好的性能,但在写入时较慢,需要重新计算及修改奇偶校验磁盘的内容。RAID 3和RAID 2有同样的应用方式,适用大档案及大量数据输出入的应用,并不适用于PC及网络服务器。\nRAID 4****\nRAID 4也使用一个校验磁盘,但和RAID 3不一样,如下图:\n磁盘0 磁盘1 磁盘2 磁盘3 磁盘4 A0-A1 B3-B4\nD1-D2\nE4-F0\n| | A2-A3 C0-C1\nD3-D4\nF1-F2\n| | A4-B0 C2-C3\nB0-B1\nF3-F4\n| | B1-B2 C4-D0\nB2-B3\nG0-G1\n| | P P\nP\nP\nRAID 4是以扇区作数据分段,各磁盘相同位置的分段形成一个校验磁盘分段(parity block),放在校验磁盘。这种方式可在不同的磁盘平行执行不同的读取命今,大幅提高磁盘阵列的读取性能;但写入数据时,因受限于校验磁盘,同一时间只能作一次,启动所有磁盘读取数据形成同一校验分段的所有数据分段,与要写入的数据做好校验计算再写入。即使如此,小型档案的写入仍然比RAID 3要快,因其校验计算较简单而非作位(bit level)的计算;但校验磁盘形成RAID 4的瓶颈,降低了性能,因有RAID 5而使得RAID 4较少使用。\nRAID 5****\nRAID5避免了RAID 4的瓶颈,方法是不用校验磁盘而将校验数据以循环的方式放在每一个磁盘中,如下图:\n磁盘0 磁盘1 磁盘2 磁盘3 磁盘4 P B3-B4\nD1-D2\nE4-F0\n| | A0-A1 P\nD3-D4\nF1-F2\n| | A2-B3 C0-C1\nP\nF3-F4\n| | A4-B0 C2-C3\nB0-B1\nP\n| | B2-B2 C4-D0\nB2-B3\nG0-G1\n磁盘阵列的第一个磁盘分段是校验值,第二个磁盘至后一个磁盘再折回第一个磁盘的分段是数据,然后第二个磁盘的分段是校验值,从第三个磁盘再折回第二个磁盘的分段是数据,以此类推,直到放完为止。图中的第一个parity block是由A0,A1…,B1,B2计算出来,第二个parity block是由B3,B4,…,C4,D0计算出来,也就是校验值是由各磁盘同一位置的分段的数据所计算出来。这种方式能大幅增加小档案的存取性能,不但可同时读取,甚至有可能同时执行多个写入的动作,如可写入数据到磁盘1而其parity block在磁盘2,同时写入数据到磁盘4而其parity block在磁盘1,这对联机交易处理(OLTP, on-line Transaction Processing)如银行系统、金融、股市等或大型数据库的处理提供了最佳的解决方案(solution),因为这些应用的每一笔数据量小,磁盘输出入频繁而且必须容错。\n事实上RAID 5的性能并无如此理想,因为任何数据的修改,都要把同一parity block的所有数据读出来修改后,做完校验计算再写回去,也就是RMW cycle(Read-Modify-Write cycle,这个cycle没有包括校验计算);正因为牵一而动全身,所以:\nR:N(可同时读取所有磁盘)\nW:1(可同时写入磁盘数)\nS:N-1(利用率)\nRAID 5的控制比较复杂,尤其是利用硬件对磁盘阵列的控制,因为这种方式的应用比其他的RAID level要掌握更多的事情,有更多的输出入需求,既要速度快,又要处理数据,计算校验值,做错误校正等,所以价格较高;其应用最好是OLTP,至于用于PC等,不见得有最佳的性能。\n3.RAID的对比：\n下面几个表列是RAID的一些性质: 操作 工作模式 最少硬盘需求量 可用容量 RAID 0 磁盘延伸和数据分布 2 T RAID 1 数据分布和镜像 2 T/2 RAID 2 共轴同步,并行传输,ECC 3 T*(n-1)/n RAID 3 共轴同步,并行传输,Parity 3 T*(n-1)/n RAID 4 数据分布，固定Parity 3 T*(n-1)/n RAID 5 数据分布，分布Parity 3 T*(n-1)/n RAID的性能与可用性： RAID Level 用户数据利用率 Bandwidth Performance Transaction Performance 数据可用性 RAID 0 1 0.25 1 0.0005 RAID 1 0.5 0.25 0.85 1 RAID 2 0.67 1 0.25 0.9999 RAID 3 0.75 1 0.25 0.9999 RAID 4 0.75 0.25 0.61 0.9999 RAID 5 0.75 0.25 0.61 0.9999 以上数据基于4个磁盘，传输块大小1K，75%的读概率，数据可用性的计算基于同样的损坏概率\n4.RAID的概述：\nRAID 0\n没有任何额外的磁盘或空间作安全准备,所以一般人不重视它,这是误解,其实它有最好的效率及空间利用率,对于追求效率的应用,非常理想,可同时用其他的RAID level或其他的备份方式以补其不足,保护重要的数据。\nRAID 1\n有最佳的安全性,100%不停机,即使有一个磁盘损坏也能照常作业而不影向其效能(对能并行存取的系统稍有影响),因为数据是作重复储存。RAID1的并行读取几乎有RAID 0的性能,因为可同时读取相互镜像的磁盘;写入也只比RAID 0略逊,因为同时写入两个磁盘并没有增加多少工作。虽然RAID 1要增加一倍的磁盘做镜像,但作为采用磁盘阵列的进入点,它是最便宜的一个方案,是新设磁盘阵列的用户之最佳选择。\nRAID 5\n在不停机及容错的表现都很好,但如有磁盘故障,对性能的影响较大,大容量的快取内存有助于维持性能,但在OLTP的应用上,因为每一笔数据或记录(record)都很小,对磁盘的存取频繁,故有一定程度的影响。某一磁盘故障时,读取该磁盘的数据需把共用同一parity block的所有数据及校验值读出来,再把故障磁盘的数据计算出来;写入时,除了要重覆读取的程序外,还要再做校验值的计算,然后再写入更新的数据及校验值;等换上新的磁盘,系统要计算整个磁盘阵列的数据以回复故障磁盘的数据,时间要很长,如系统的工作负载很重的话,有很多输出入的需求在排队等候时,会把系统的性能拉下来。但如使用硬件磁盘阵列的话,其性能就可以得到大幅度的改进,因为硬件磁盘阵列如DFTraid系列本身有内置的CPU与主机系统并行运作,所有存取磁盘的输出入工作都在磁盘阵列本身完成,不花费主机的时间,配合磁盘阵列的快取内存的使用,可以提高系统的整体性能,而优越的总线控制更能增加数据的传输速率,即使在磁盘故障的情况下,主机系统的性能也不会有明显的降低。RAID 5要做的事情太多,所以价格较贵,不适于小系统,但如果是大系统使用大的磁盘阵列的话,RAID 5却是最便宜的方案。\n总而言之,RAID 0及RAID 1最适合PC及图形工作站的用户,提供最佳的性能及最便宜的价格,所以RAID 0及RAID 1多是使用IDE界面,以低成本符合PC市埸的需求。RAID 2及RAID 3适用于大档案且输入输出需求不频繁的应用如影像处理及CAD/CAM等;而RAID 5则适用于银行、金融、股市、数据库等大型数据处理中心的OLTP应用;RAID 4与RAID 5有相同的特性及应用方式,但有其先天的限制,所以并不受推荐。\n5.磁盘阵列的额外容错功能：Spare or Standby driver\n事实上容错功能已成为磁盘阵列最受青睐的特性,为了加强容错的功能以及使系统在磁盘故障的情况下能迅速的重建数据,以维持系统的性能,一般的磁盘阵列系统都可使用热备份(hot spare or hot standby driver)的功能,所谓热备份是在建立(configure)磁盘阵列系统的时候,将其中一磁盘指定为后备磁盘,此一磁盘在平常并不操作,但若阵列中某一磁盘发生故障时,磁盘阵列即以后备磁盘取代故障磁盘,并自动将故障磁盘的数据重建(rebuild)在后备磁盘之上,因为反应快速,加上快取内存减少了磁盘的存取,所以数据重建很快即可完成,对系统的性能影响不大。对于要求不停机的大型数据处理中心或控制中心而言,热备份更是一项重要的功能,因为可避免晚间或无人持守时发生磁盘故障所引起的种种不便。\n另一个额外的容错功能是坏扇区转移(bad sector reassignment)。坏扇区是磁盘故障的主要原因,通常磁盘在读写时发生坏扇区的情况即表示此磁盘故障,不能再作读写,甚至有很多系统会因为不能完成读写的动作而死机,但若因为某一扇区的损坏而使工作不能完成或要更换磁盘,则使得系统性能大打折扣,而系统的维护成本也未免太高了。坏扇区转移是当磁盘阵列系统发现磁盘有坏扇区时,以另一空白且无故障的扇区取代该扇区,以延长磁盘的使用寿命,减少坏磁盘的发生率以及系统的维护成本。所以坏扇区转移功能使磁盘阵列具有更好的容错性,同时使整个系统有最好的成本效益比。其他如可外接电池备援磁盘阵列的快取内存,以避免突然断电时数据尚未写回磁盘而损失;或在RAID 1时作写入一致性的检查等,虽是小技术,但亦不可忽视。\n6.硬件磁盘阵列还是软件磁盘阵列\n市面上有所谓硬件磁盘阵列与软件磁盘阵列之分,因为软件磁盘阵列是使用一块SCSI卡与磁盘连接,一般用户误以为是硬件磁盘阵列。以上所述主要是针对硬件磁盘阵列,其与软件磁盘阵列有几个最大的区别:\nl 一个完整的磁盘阵列硬件与系统相接。\nl 内置CPU,与主机并行运作,所有的I/O都在磁盘阵列中完成,减轻主机的工作负载,增加系统整体性能。\nl 有卓越的总线主控(bus mastering)及DMA(Direct Memory Access)能力,加速数据的存取及传输性能。\nl 与快取内存结合在一起,不但增加数据的存取及传输性能,更因减少对磁盘的存取而增加磁盘的寿命。\nl 能充份利用硬件的特性,反应快速。\n软件磁盘阵列是一个程序,在主机执行,透过一块SCSI卡与磁盘相接形成阵列,它最大的优点是便宜,因为没有硬件成本(包括研发、生产、维护等),而SCSI卡很便宜(亦有的软件磁盘阵列使用指定的很贵的SCSI卡);它最大的缺点是使主机多了很多进程(process),增加了主机的负担,尤其是输出入需求量大的系统。目前市面上的磁盘阵列系统大部份是硬件磁盘阵列,软件磁盘阵列较少。\n7.IDE磁盘阵列还是SCSI磁盘阵列\n目前使用在磁盘输出入的界面主要有两种:\n1. IDE (Integrated Drive Electronics)\n是广泛使用在PC上的磁盘驱动器界面,一般而言,其传输速度从磁盘到磁盘缓冲器(medium to drive buffer)是1.5-2.5MB/Sec,从缓冲器到界面(drive buffer to drive interface)约4.0-6.0MB/Sec,而且新的设计其速率有大幅的改进,如增强型IDE界面(mode 4)在PCI(Peripheral Component Interconnect)总线上的传输速率可达33MB/Sec。\n2. SCSI (Small Computer Standard Interface)\nSCSI是较高级(high level)的界面,可用于主机,磁盘,磁带,打印机等,因为是高阶的界面,规格较为复杂,一般自带控制器,也较为复杂,这就是SCSI磁盘为什么比IDE磁盘费的原因。但SCSI界面能较有效的利用硬件特性而提高其速度。其控制器还能对主机发给SCSI磁盘的命令进行缓冲、排队,并进行优化处理(命令队列)。现在较流行的是标准SCSI-2和SCSI-3。有两种规格,FAST SCSI(SCSI-2)的同步传输速率为10MB/Sec,数据传输宽度为8 bit, WIDE SCSI的数据传输宽度可达16-bit。Ultra SCSI(SCSI-3)的同步传输速率为20MB/Sec,Ultra Wide SCSI的同步传输速率为40MB/Sec,数据传输宽度可达32-bit。SCSI磁盘有虽有较高的传输速度,但受限于磁盘的存取速度及磁盘至SCSI界面的传输速度而不能充分发挥其性能(因为磁盘的机械动作难于有大幅度的改进);其命令分析程序(command phase)也较复杂。对单机来言，磁盘数量越多,主机找到特定的数据的时间越长,但对磁盘阵列来言,由于是多个磁盘一起并行处理,则表现为磁盘数量越多,速度越快。\n以上界面的直接反应是单任务时IDE比SCSI快,多任务时SCSI较快,这可从用IDE盘和SCSI盘做多用户、多任务的操作系统(如UNIX、Windows/NT等)的系统盘时的启动时间的差别中明显看出。在单机时则不一定。我们看一个界面是否较快,不应只看其传崐输速度的高低而应就整个输入/输出的流程看,因为磁盘存取的机械动作比不上电脑的传输速率。IDE界面简单,反应快速,用于PC单机的小型的磁盘阵列其效果可能比SCSI为佳;但较大型的磁盘阵列就非SCSI界面莫属,因为阵列中的各个磁盘一起作存取的动作,能充分发挥SCSI的传输速率快及多工的特点。\n此外IDE因为其配线规格的关系,不能作热插拔(hot swap),也就是不能在工作中带电插拔磁盘,而其线缆即使是增强型IDE也只有18寸,不能接在机箱之外,难于形成大的阵列,也就是只适用于PC低层次的用户。SCSI缆线在差分传输模式(differential transmission mode)下最大长度为25米,单端传输模式(single-ended transmission mode)时最大长度为6米,而一条SCSI总线可连接8台系统或各种不同的装置,扩充性很强,可形成很大的磁盘阵列空间;SCSI规格完备,容错能力很好,可带电插拔磁盘,是外接式装置无可取代的界面。\n8. 磁盘阵列卡还是磁盘阵列控制器\n磁盘阵列控制卡一般用于小系统，供单机使用。与主机共用电源，在关闭主机电源时存在丢失Cache中的数据的的危险。磁盘阵列控制卡只有常用总线方式的接口，其驱动程序与主机、主机所用的操作系统都有关系，有软、硬件兼容性问题并潜在地增加了系统的不安定因素。在更换磁盘阵列卡时要冒磁盘损坏，资料失落，随时停机的风险。\n独立式磁盘阵列控制一般用于较大型系统,可分为两种：\n单通道磁盘阵列和多通道式磁盘阵列，单通道磁盘阵列只能接一台主机，有很大的扩充限制。多通道磁盘阵列可接多个系统同时使用,以群集(cluster)的方式共用磁盘阵列,这使内接式阵列控制及单接式磁盘阵列无用武之地。DFT数据容错公司的DFTraid Rack Mount和DFTraid Tower等系统,都是独立形式的磁盘阵列子系统，其本身与主机系统的硬件及操作环境无关，只通过SCSI线缆与主机相接，主机把它当作一般的磁盘，所有的输出入动作都在磁盘阵列上完成，与主机的操作无关，所以可接任何可使用SCSI界面的主机。DFTraid Rack Mount和DFTraid Tower两系统最多可有六个SCSI通道，可同时连接5台主机;而DFTraid 5000系列则有9个通道,可同时连接多达8台主机，使之一起共用磁盘阵列子系统。这种方式的磁盘阵列既可给单机使用，又可给群集多机使用，对用户对增加阵列中的磁盘数量限制较小，并可用于备援及并行的容错电脑系统，特别适合较大的系统用户，使这些用户可从封闭的环境中解放出来。\n9. RAID5建立过程\n第一步：\n[](https://fastly.jsdelivr.net/gh/sethdang/sethPic/blog_img/5150429123851676322.jpg\n","wordCount":"10599","inLanguage":"zh-cn","datePublished":"2007-03-28T13:53:16+08:00","dateModified":"2007-03-28T13:53:16+08:00","author":{"@type":"Person","name":"Seth"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://seth.dpdns.org/posts/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97disk-array/"},"publisher":{"@type":"Organization","name":"Seth Dang'S","logo":{"@type":"ImageObject","url":"https://seth.dpdns.org/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://seth.dpdns.org/ accesskey=h title="Seth Dang'S (Alt + H)">Seth Dang'S</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://seth.dpdns.org/>Home</a>&nbsp;»&nbsp;<a href=https://seth.dpdns.org/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">磁盘阵列(Disk Array)</h1><div class=post-meta><span title='2007-03-28 13:53:16 +0800 +0800'>March 28, 2007</span>&nbsp;·&nbsp;<span>22 min</span>&nbsp;·&nbsp;<span>10599 words</span>&nbsp;·&nbsp;<span>Seth</span></div></header><div class=post-content><p>**</p><p>1.为什么需要磁盘阵列</p><p>如何增加磁盘的存取(access)速度,如何防止数据因磁盘的故障而失落及如何有效的利用磁盘空间,一直是电脑专业人员和用户的困扰;而大容量磁盘的价格非常昂贵,对用户形成很大的负担。磁盘阵列技术的产生一举解决了这些问题。</p><p>过去十年来,CPU的处理速度增加了五十倍有多,内存(memory)的存取速度亦大幅增加,而数据储存装置&ndash;主要是磁盘(hard disk)&ndash;的存取速度只增加了三、四倍,形成电脑系统的瓶颈,拉低了电脑系统的整体性能(throughput),若不能有效的提升磁盘的存取速度,CPU、内存及磁盘间的不平衡将使CPU及内存的改进形成浪费。</p><p>目前改进磁盘存取速度的的方式主要有两种。一是磁盘快取控制(disk cache controller),它将从磁盘读取的数据存在快取内存(cache memory)中以减少磁盘存取的次数,数据的读写都在快取内存中进行,大幅增加存取的速度,如要读取的数据不在快取内存中,或要写数据到磁盘时,才做磁盘的存取动作。这种方式在单工环境(single-tasking environment)如DOS之下,对大量数据的存取有很好的性能(量小且频繁的存取则不然),但在多工(multi-tasking)环境之下(因为要不停的作数据交换(swapping)的动作)或数据库(database)的存取(因为每一记录都很小)就不能显示其性能。这种方式没有任何安全保障。其二是使用磁盘阵列的技术。磁盘阵列是把多个磁盘组成一个阵列,当作单一磁盘使用,它将数据以分段(striping)的方式储存在不同的磁盘中,存取数据时,阵列中的相关磁盘一起动作,大幅减低数据的存取时间,同时有更佳的空间利用率。磁盘阵列所利用的不同的技术,称为RAID level,不同的level针对不同的系统及应用,以解决数据安全的问题。</p><p>一般高性能的磁盘阵列都是以硬件的形式来达成,进一步的把磁盘快取控制及磁盘阵列结合在一个控制器(RAID controller)或控制卡上,针对不同的用户解决人们对磁盘输出入系统的四大要求:</p><p>(1)增加存取速度,</p><p>(2)容错(fault tolerance),即安全性</p><p>(3)有效的利用磁盘空间;</p><p>(4)尽量的平衡CPU,内存及磁盘的性能差异,提高电脑的整体工作性能。</p><p>2.磁盘阵列原理</p><p>磁盘阵列中针对不同的应用使用的不同技术,称为RAID level, RAID是Redundant Array of Inexpensive Disks的缩写,而每一level代表一种技术,目前业界公认的标准是RAID 0~RAID 5。这个level并不代表技术的高低,level 5并不高于level 3,level 1也不低过level 4,至于要选择那一种RAID level的产品,纯视用户的操作环境(operating environment)及应用(application)而定,与level的高低没有必然的关系。RAID 0及RAID 1适用于PC及PC相关的系统如小型的网络服务器(network server)及需要高磁盘容量与快速磁盘存取的工作站等,因为比较便宜,但因一般人对磁盘阵列不了解,没有看到磁盘阵列对他们价值,市场尚未打开;RAID 2及RAID 3适用于大型电脑及影像、CAD/CAM等处理;RAID 5多用于OLTP,因有金融机构及大型数据处理中心的迫切需要,故使用较多而较有名气,但也因此形成很多人对磁盘阵列的误解,以为磁盘阵列非要RAID 5不可;RAID 4较少使用,因为两者有其共同之处,而RAID 4有其先天的限制。其他如RAID 6,RAID 7,乃至RAID 10等,都是厂商各做各的,并无一致的标准,在此不作说明。介绍各个RAID level之前,先看看形成磁盘阵列的两个基本技术:</p><p>译为磁盘延伸,能确切的表示disk spanning这种技术的含义。如下图所示,DFTraid 磁盘阵列控制器,联接了四个磁盘:</p><p>这四个磁盘形成一个阵列(array),而磁盘阵列的控制器(RAID controller)是将此四个磁盘视为单一的磁盘,如DOS环境下的C:盘。这是disk spanning的意义,因为把小容量的磁盘延伸为大容量的单一磁盘,用户不必规划数据在各磁盘的分布,而且提高了磁盘空间的使用率。DFTraid的SCSI磁盘阵列更可连接几十个磁盘，形成数十GB到数百GB的阵列,使磁盘容量几乎可作无限的延伸;而各个磁盘一起作取存的动作,比单一磁盘更为快捷。很明显的,有此阵列的形成而产生RAID的各种技术。我们也可从上图看出inexpensive(便宜)的意义,因为四个250MBbytes的磁盘比一个1GBytes的磁盘要便宜,尤其以前大磁盘的价格非常昴贵,但在磁盘越来越便宜的今天,inexpensive已非磁盘阵列的重点,虽然对于需要大磁盘容量的系统,仍是考虑的要点。</p><p>磁盘 因为磁盘阵列是将同一阵列的多个磁盘视为单一的虚拟磁盘(virtual disk),所以其数据是以分段(block or segment)的方式顺序存放在磁盘阵列中,如下图:</p><table><thead><tr><th>磁盘0</th><th></th><th>磁盘1</th><th></th><th>磁盘2</th><th></th><th>磁盘3</th></tr></thead><tbody><tr><td>A0-A1</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><hr><p>B0-B1<br>C0-C1<br>D0-D1</p><h2 id=----a2-a3>| | A2-A3<a hidden class=anchor aria-hidden=true href=#----a2-a3>#</a></h2><p>B2-B3<br>C2-C3<br>D2-D3</p><h2 id=----a4-a5>| | A4-A5<a hidden class=anchor aria-hidden=true href=#----a4-a5>#</a></h2><p>B4-B5<br>C4-C5<br>D4-C5</p><h2 id=----a6-a7>| | A6-A7<a hidden class=anchor aria-hidden=true href=#----a6-a7>#</a></h2><p>B6-B7<br>C6-C7<br>D6-D7</p><p>数据按需要分段,从第一个磁盘开始放,放到最後一个磁盘再回到第一个磁盘放起,直到数据分布完毕。至于分段的大小视系统而定,有的系统或以1KB最有效率,或以4KB,或以6KB,甚至是4MB或8MB的,但除非数据小于一个扇区(sector,即521bytes),否则其分段应是512byte的倍数。因为磁盘的读写是以一个扇区为单位,若数据小于512bytes,系统读取该扇区后,还要做组合或分组(视读或写而定)的动作,浪费时间。从上图我们可以看出,数据以分段于在不同的磁盘,整个阵列的各个磁盘可同时作读写,故数据分段使数据的存取有最好的效率,理论上本来读一个包含四个分段的数据所需要的时间约=(磁盘的access time +数据的transfer time)X4次,现在只要一次就可以完成。</p><p>若以N表示磁盘的数目,R表示读取,W表示写入,S表示可使用空间,则数据分段的性能为:</p><p>R:N(可同时读取所有磁盘)</p><p>W:N(可同时写入所有磁盘)</p><p>S:N(可利用所有的磁盘,并有最佳的使用率)</p><p>Disk striping也称为RAID 0,很多人以为RAID 0没有甚么,其实这是非常错误的观念,因为RAID 0使磁盘的输出入有最高的效率。而磁盘阵列有更好效率的原因除数据分段外,它可以同时执行多个输出入的要求,因为阵列中的每一个磁盘都能独立动作,分段放在不同的磁盘,不同的磁盘可同时作读写,而且能在快取内存及磁盘作并行存取(parallel access)的动作,但只有硬件的磁盘阵列才有此性能表现。</p><p>从上面两点我们可以看出,disk spanning定义了RAID的基本形式,提供了一个便宜、灵活、高性能的系统结构,而disk striping解决了数据的存取效率和磁盘的利用率问题,RAID 1至RAID 5是在此基础上提供磁盘安全的方案。</p><p><strong>RAID 1</strong></p><p>RAID 1是使用磁盘镜像(disk mirroring)的技术。磁盘镜像应用在RAID 1之前就在很多系统中使用,它的方式是在工作磁盘(working disk)之外再加一额外的备份磁盘(backup disk),两个磁盘所储存的数据完全一样,数据写入工作磁盘的同时亦写入备份磁盘。磁盘镜像不见得就是RAID 1,如Novell NetWare亦有提供磁盘镜像的功能,但并不表示NetWare有了RAID 1的功能。一般磁盘镜像和RAID 1有二点最大的不同:</p><p>RAID 1无工作磁盘和备份磁盘之分,多个磁盘可同时动作而有重叠(overlapping)读取的功能,甚至不同的镜像磁盘可同时作写入的动作,这是一种最佳化的方式,称为负载平衡(load-balance)。例如有多个用户在同一时间要读取数据,系统能同时驱动互相镜像的磁盘,同时读取数据,以减轻系统的负载,增加I/O的性能。</p><p>RAID 1的磁盘是以磁盘延伸的方式形成阵列,而数据是以数据分段的方式作储存,因而在读取时,它几乎和RAID 0有同样的性能。从RAID的结构就可以很清楚的看出RAID 1和一般磁盘镜像的不同。</p><p>下图为RAID 1,每一笔数据都储存两份</p><table><thead><tr><th>磁盘0</th><th></th><th>磁盘1</th><th></th><th>磁盘0</th><th></th><th>磁盘1</th></tr></thead><tbody><tr><td>A0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><hr><p>A2<br>A4<br>B1</p><h2 id=----a1>| | A1<a hidden class=anchor aria-hidden=true href=#----a1>#</a></h2><p>A3<br>B0<br>B2</p><h2 id=----a0>| | A0<a hidden class=anchor aria-hidden=true href=#----a0>#</a></h2><p>A2<br>A4<br>B1</p><h2 id=----a1-1>| | A1<a hidden class=anchor aria-hidden=true href=#----a1-1>#</a></h2><p>A3<br>B0<br>B2</p><p>从上图可以看出:</p><p>R:N(可同时读取所有磁盘)</p><p>W:N/2(同时写入磁盘数)</p><p>S:N/2(利用率)</p><p>读取数据时可用到所有的磁盘,充分发挥数据分段的优点;写入数据时,因为有备份,所以要写入两个磁盘,其效率是N/2,磁盘空间的使用率也只有全部磁盘的一半。</p><p>很多人以为RAID 1要加一个额外的磁盘,形成浪费而不看好RAID 1,事实上磁盘越来越便宜,并不见得造成负担,况且RAID 1有最好的容错(fault tolerance)能力,其效率也是除RAID 0之外最好的。我们可视应用的不同,在同一磁盘阵列中使用不同的RAID level,如华艺科技公司的DFTraid系列都可同一磁盘阵列中定义八个逻辑磁盘(logic disk),分别使用不同的RAID level,分为C:,D:及E:三个逻辑磁盘(或LUN0,LUN1,LUN2).</p><p>RAID 1完全做到了容错包括不停机(non-stop),当某一磁盘发生故障,可将此磁盘拆下来而不影向其他磁盘的操作;待新的磁盘换上去之后,系统即时做镜像,将数据重新复上去,RAID 1在容错及存取的性能上是所有RAID level之冠。</p><p>在磁盘阵列的技术上,从RAID 1到RAID 5,不停机的意思表示在工作时如发生磁盘故障,系统能持续工作而不停顿,仍然可作磁盘的存取,正常的读写数据;而容错则表示即使磁盘故障,数据仍能保持完整,可让系统存取到正确的数据,而SCSI的磁盘阵列更可在工作中抽换磁盘,并可自动重建故障磁盘的数据。磁盘阵列之所以能做到容错及不停机,是因为它有冗余的磁盘空间可资利用,这也就是Redundant的意义。</p><p><strong>RAID 2</strong></p><p>RAID 2是把数据分散为位元(bit)或块(block),加入海明码Hamming Code,在磁盘阵列中作间隔写入(interleaving)到每个磁盘中,而且地址(address)都一样,也就是在各个磁盘中,其数据都在相同的磁道(cylinder or track)及扇区中。RAID 2的设计是使用共轴同步(spindle synchronize)的技术,存取数据时,整个磁盘阵列一起动作,在各作磁盘的相同位置作平行存取,所以有最好的存取时间(access time),其总线(bus)是特别的设计,以大带宽(band wide)并行传输所存取的数据,所以有最好的传输时间(transfer time)。在大型档案的存取应用,RAID 2有最好的性能,但如果档案太小,会将其性能拉下来,因为磁盘的存取是以扇区为单位,而RAID 2的存取是所有磁盘平行动作,而且是作单位元的存取,故小于一个扇区的数据量会使其性能大打折扣。RAID 2是设计给需要连续且大量数据的电脑使用的,如大型电脑(mainframe to supercomputer)、作影像处理或CAD/CAM的工作站(workstation)等,并不适用于一般的多用户环境、网络服务器(network server),小型机或PC。</p><p>RAID 2的安全采用内存阵列(memory array)的技术,使用多个额外的磁盘作单位错误校正(single-bit correction)及双位错误检测(double-bit detection);至于需要多少个额外的磁盘,则视其所采用的方法及结构而定,例如八个数据磁盘的阵列可能需要三个额外的磁盘,有三十二个数据磁盘的高档阵列可能需要七个额外的磁盘。</p><p><strong>RAID 3</strong></p><p>RAID 3的数据储存及存取方式都和RAID 2一样,但在安全方面以奇偶校验(parity check)取代海明码做错误校正及检测,所以只需要一个额外的校检磁盘(parity disk)。奇偶校验值的计算是以各个磁盘的相对应位作XOR的逻辑运算,然后将结果写入奇偶校验磁盘,任何数据的修改都要做奇偶校验计算,如下图:</p><table><thead><tr><th>磁盘0</th><th></th><th>磁盘1</th><th></th><th>磁盘2</th><th></th><th>磁盘3</th><th></th><th>磁盘4</th></tr></thead><tbody><tr><td>A0</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><hr><p>A4<br>B3<br>C2</p><h2 id=----a1-2>| | A1<a hidden class=anchor aria-hidden=true href=#----a1-2>#</a></h2><p>B0<br>B4<br>C3</p><h2 id=----a2>| | A2<a hidden class=anchor aria-hidden=true href=#----a2>#</a></h2><p>A1<br>C0<br>C4</p><h2 id=----a3>| | A3<a hidden class=anchor aria-hidden=true href=#----a3>#</a></h2><p>A2<br>C1<br>D0</p><h2 id=----p>| | P<a hidden class=anchor aria-hidden=true href=#----p>#</a></h2><p>P<br>P<br>P</p><p>如某一磁盘故障,换上新的磁盘后,整个磁盘阵列(包括奇偶校验磁盘)需重新计算一次,将故障磁盘的数据恢复并写入新磁盘中;如奇偶校验磁盘故障,则重新计算奇偶校验值,以达容错的要求.</p><p>较之RAID 1及RAID 2,RAID 3有85%的磁盘空间利用率,其性能比RAID 2稍差,因为要做奇偶校验计算;共轴同步的平行存取在读档案时有很好的性能,但在写入时较慢,需要重新计算及修改奇偶校验磁盘的内容。RAID 3和RAID 2有同样的应用方式,适用大档案及大量数据输出入的应用,并不适用于PC及网络服务器。</p><p><strong>RAID 4</strong>****</p><p>RAID 4也使用一个校验磁盘,但和RAID 3不一样,如下图:</p><table><thead><tr><th>磁盘0</th><th></th><th>磁盘1</th><th></th><th>磁盘2</th><th></th><th>磁盘3</th><th></th><th>磁盘4</th></tr></thead><tbody><tr><td>A0-A1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><hr><p>B3-B4<br>D1-D2<br>E4-F0</p><h2 id=----a2-a3-1>| | A2-A3<a hidden class=anchor aria-hidden=true href=#----a2-a3-1>#</a></h2><p>C0-C1<br>D3-D4<br>F1-F2</p><h2 id=----a4-b0>| | A4-B0<a hidden class=anchor aria-hidden=true href=#----a4-b0>#</a></h2><p>C2-C3<br>B0-B1<br>F3-F4</p><h2 id=----b1-b2>| | B1-B2<a hidden class=anchor aria-hidden=true href=#----b1-b2>#</a></h2><p>C4-D0<br>B2-B3<br>G0-G1</p><h2 id=----p-1>| | P<a hidden class=anchor aria-hidden=true href=#----p-1>#</a></h2><p>P<br>P<br>P</p><p>RAID 4是以扇区作数据分段,各磁盘相同位置的分段形成一个校验磁盘分段(parity block),放在校验磁盘。这种方式可在不同的磁盘平行执行不同的读取命今,大幅提高磁盘阵列的读取性能;但写入数据时,因受限于校验磁盘,同一时间只能作一次,启动所有磁盘读取数据形成同一校验分段的所有数据分段,与要写入的数据做好校验计算再写入。即使如此,小型档案的写入仍然比RAID 3要快,因其校验计算较简单而非作位(bit level)的计算;但校验磁盘形成RAID 4的瓶颈,降低了性能,因有RAID 5而使得RAID 4较少使用。</p><p><strong>RAID 5</strong>****</p><p>RAID5避免了RAID 4的瓶颈,方法是不用校验磁盘而将校验数据以循环的方式放在每一个磁盘中,如下图:</p><table><thead><tr><th>磁盘0</th><th></th><th>磁盘1</th><th></th><th>磁盘2</th><th></th><th>磁盘3</th><th></th><th>磁盘4</th></tr></thead><tbody><tr><td>P</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><hr><p>B3-B4<br>D1-D2<br>E4-F0</p><h2 id=----a0-a1>| | A0-A1<a hidden class=anchor aria-hidden=true href=#----a0-a1>#</a></h2><p>P<br>D3-D4<br>F1-F2</p><h2 id=----a2-b3>| | A2-B3<a hidden class=anchor aria-hidden=true href=#----a2-b3>#</a></h2><p>C0-C1<br>P<br>F3-F4</p><h2 id=----a4-b0-1>| | A4-B0<a hidden class=anchor aria-hidden=true href=#----a4-b0-1>#</a></h2><p>C2-C3<br>B0-B1<br>P</p><h2 id=----b2-b2>| | B2-B2<a hidden class=anchor aria-hidden=true href=#----b2-b2>#</a></h2><p>C4-D0<br>B2-B3<br>G0-G1</p><p>磁盘阵列的第一个磁盘分段是校验值,第二个磁盘至后一个磁盘再折回第一个磁盘的分段是数据,然后第二个磁盘的分段是校验值,从第三个磁盘再折回第二个磁盘的分段是数据,以此类推,直到放完为止。图中的第一个parity block是由A0,A1&mldr;,B1,B2计算出来,第二个parity block是由B3,B4,&mldr;,C4,D0计算出来,也就是校验值是由各磁盘同一位置的分段的数据所计算出来。这种方式能大幅增加小档案的存取性能,不但可同时读取,甚至有可能同时执行多个写入的动作,如可写入数据到磁盘1而其parity block在磁盘2,同时写入数据到磁盘4而其parity block在磁盘1,这对联机交易处理(OLTP, on-line Transaction Processing)如银行系统、金融、股市等或大型数据库的处理提供了最佳的解决方案(solution),因为这些应用的每一笔数据量小,磁盘输出入频繁而且必须容错。</p><p>事实上RAID 5的性能并无如此理想,因为任何数据的修改,都要把同一parity block的所有数据读出来修改后,做完校验计算再写回去,也就是RMW cycle(Read-Modify-Write cycle,这个cycle没有包括校验计算);正因为牵一而动全身,所以:</p><p>R:N(可同时读取所有磁盘)</p><p>W:1(可同时写入磁盘数)</p><p>S:N-1(利用率)</p><p>RAID 5的控制比较复杂,尤其是利用硬件对磁盘阵列的控制,因为这种方式的应用比其他的RAID level要掌握更多的事情,有更多的输出入需求,既要速度快,又要处理数据,计算校验值,做错误校正等,所以价格较高;其应用最好是OLTP,至于用于PC等,不见得有最佳的性能。</p><p>3.RAID的对比：</p><table><thead><tr><th>下面几个表列是RAID的一些性质: 操作</th><th>工作模式</th><th>最少硬盘需求量</th><th>可用容量</th></tr></thead><tbody><tr><td>RAID 0</td><td>磁盘延伸和数据分布</td><td>2</td><td>T</td></tr><tr><td>RAID 1</td><td>数据分布和镜像</td><td>2</td><td>T/2</td></tr><tr><td>RAID 2</td><td>共轴同步,并行传输,ECC</td><td>3</td><td>T*(n-1)/n</td></tr><tr><td>RAID 3</td><td>共轴同步,并行传输,Parity</td><td>3</td><td>T*(n-1)/n</td></tr><tr><td>RAID 4</td><td>数据分布，固定Parity</td><td>3</td><td>T*(n-1)/n</td></tr><tr><td>RAID 5</td><td>数据分布，分布Parity</td><td>3</td><td>T*(n-1)/n</td></tr></tbody></table><table><thead><tr><th>RAID的性能与可用性： RAID Level</th><th>用户数据利用率</th><th>Bandwidth Performance</th><th>Transaction Performance</th><th>数据可用性</th></tr></thead><tbody><tr><td>RAID 0</td><td>1</td><td>0.25</td><td>1</td><td>0.0005</td></tr><tr><td>RAID 1</td><td>0.5</td><td>0.25</td><td>0.85</td><td>1</td></tr><tr><td>RAID 2</td><td>0.67</td><td>1</td><td>0.25</td><td>0.9999</td></tr><tr><td>RAID 3</td><td>0.75</td><td>1</td><td>0.25</td><td>0.9999</td></tr><tr><td>RAID 4</td><td>0.75</td><td>0.25</td><td>0.61</td><td>0.9999</td></tr><tr><td>RAID 5</td><td>0.75</td><td>0.25</td><td>0.61</td><td>0.9999</td></tr></tbody></table><p>以上数据基于4个磁盘，传输块大小1K，75%的读概率，数据可用性的计算基于同样的损坏概率</p><p>4.RAID的概述：</p><p>RAID 0</p><p>没有任何额外的磁盘或空间作安全准备,所以一般人不重视它,这是误解,其实它有最好的效率及空间利用率,对于追求效率的应用,非常理想,可同时用其他的RAID level或其他的备份方式以补其不足,保护重要的数据。</p><p>RAID 1</p><p>有最佳的安全性,100%不停机,即使有一个磁盘损坏也能照常作业而不影向其效能(对能并行存取的系统稍有影响),因为数据是作重复储存。RAID1的并行读取几乎有RAID 0的性能,因为可同时读取相互镜像的磁盘;写入也只比RAID 0略逊,因为同时写入两个磁盘并没有增加多少工作。虽然RAID 1要增加一倍的磁盘做镜像,但作为采用磁盘阵列的进入点,它是最便宜的一个方案,是新设磁盘阵列的用户之最佳选择。</p><p>RAID 5</p><p>在不停机及容错的表现都很好,但如有磁盘故障,对性能的影响较大,大容量的快取内存有助于维持性能,但在OLTP的应用上,因为每一笔数据或记录(record)都很小,对磁盘的存取频繁,故有一定程度的影响。某一磁盘故障时,读取该磁盘的数据需把共用同一parity block的所有数据及校验值读出来,再把故障磁盘的数据计算出来;写入时,除了要重覆读取的程序外,还要再做校验值的计算,然后再写入更新的数据及校验值;等换上新的磁盘,系统要计算整个磁盘阵列的数据以回复故障磁盘的数据,时间要很长,如系统的工作负载很重的话,有很多输出入的需求在排队等候时,会把系统的性能拉下来。但如使用硬件磁盘阵列的话,其性能就可以得到大幅度的改进,因为硬件磁盘阵列如DFTraid系列本身有内置的CPU与主机系统并行运作,所有存取磁盘的输出入工作都在磁盘阵列本身完成,不花费主机的时间,配合磁盘阵列的快取内存的使用,可以提高系统的整体性能,而优越的总线控制更能增加数据的传输速率,即使在磁盘故障的情况下,主机系统的性能也不会有明显的降低。RAID 5要做的事情太多,所以价格较贵,不适于小系统,但如果是大系统使用大的磁盘阵列的话,RAID 5却是最便宜的方案。</p><p>总而言之,RAID 0及RAID 1最适合PC及图形工作站的用户,提供最佳的性能及最便宜的价格,所以RAID 0及RAID 1多是使用IDE界面,以低成本符合PC市埸的需求。RAID 2及RAID 3适用于大档案且输入输出需求不频繁的应用如影像处理及CAD/CAM等;而RAID 5则适用于银行、金融、股市、数据库等大型数据处理中心的OLTP应用;RAID 4与RAID 5有相同的特性及应用方式,但有其先天的限制,所以并不受推荐。</p><p>5.磁盘阵列的额外容错功能：Spare or Standby driver</p><p>事实上容错功能已成为磁盘阵列最受青睐的特性,为了加强容错的功能以及使系统在磁盘故障的情况下能迅速的重建数据,以维持系统的性能,一般的磁盘阵列系统都可使用热备份(hot spare or hot standby driver)的功能,所谓热备份是在建立(configure)磁盘阵列系统的时候,将其中一磁盘指定为后备磁盘,此一磁盘在平常并不操作,但若阵列中某一磁盘发生故障时,磁盘阵列即以后备磁盘取代故障磁盘,并自动将故障磁盘的数据重建(rebuild)在后备磁盘之上,因为反应快速,加上快取内存减少了磁盘的存取,所以数据重建很快即可完成,对系统的性能影响不大。对于要求不停机的大型数据处理中心或控制中心而言,热备份更是一项重要的功能,因为可避免晚间或无人持守时发生磁盘故障所引起的种种不便。</p><p>另一个额外的容错功能是坏扇区转移(bad sector reassignment)。坏扇区是磁盘故障的主要原因,通常磁盘在读写时发生坏扇区的情况即表示此磁盘故障,不能再作读写,甚至有很多系统会因为不能完成读写的动作而死机,但若因为某一扇区的损坏而使工作不能完成或要更换磁盘,则使得系统性能大打折扣,而系统的维护成本也未免太高了。坏扇区转移是当磁盘阵列系统发现磁盘有坏扇区时,以另一空白且无故障的扇区取代该扇区,以延长磁盘的使用寿命,减少坏磁盘的发生率以及系统的维护成本。所以坏扇区转移功能使磁盘阵列具有更好的容错性,同时使整个系统有最好的成本效益比。其他如可外接电池备援磁盘阵列的快取内存,以避免突然断电时数据尚未写回磁盘而损失;或在RAID 1时作写入一致性的检查等,虽是小技术,但亦不可忽视。</p><p>6.硬件磁盘阵列还是软件磁盘阵列</p><p>市面上有所谓硬件磁盘阵列与软件磁盘阵列之分,因为软件磁盘阵列是使用一块SCSI卡与磁盘连接,一般用户误以为是硬件磁盘阵列。以上所述主要是针对硬件磁盘阵列,其与软件磁盘阵列有几个最大的区别:</p><p>l 一个完整的磁盘阵列硬件与系统相接。</p><p>l 内置CPU,与主机并行运作,所有的I/O都在磁盘阵列中完成,减轻主机的工作负载,增加系统整体性能。</p><p>l 有卓越的总线主控(bus mastering)及DMA(Direct Memory Access)能力,加速数据的存取及传输性能。</p><p>l 与快取内存结合在一起,不但增加数据的存取及传输性能,更因减少对磁盘的存取而增加磁盘的寿命。</p><p>l 能充份利用硬件的特性,反应快速。</p><p>软件磁盘阵列是一个程序,在主机执行,透过一块SCSI卡与磁盘相接形成阵列,它最大的优点是便宜,因为没有硬件成本(包括研发、生产、维护等),而SCSI卡很便宜(亦有的软件磁盘阵列使用指定的很贵的SCSI卡);它最大的缺点是使主机多了很多进程(process),增加了主机的负担,尤其是输出入需求量大的系统。目前市面上的磁盘阵列系统大部份是硬件磁盘阵列,软件磁盘阵列较少。</p><p>7.IDE磁盘阵列还是SCSI磁盘阵列</p><p>目前使用在磁盘输出入的界面主要有两种:</p><p>1. IDE (Integrated Drive Electronics)</p><p>是广泛使用在PC上的磁盘驱动器界面,一般而言,其传输速度从磁盘到磁盘缓冲器(medium to drive buffer)是1.5-2.5MB/Sec,从缓冲器到界面(drive buffer to drive interface)约4.0-6.0MB/Sec,而且新的设计其速率有大幅的改进,如增强型IDE界面(mode 4)在PCI(Peripheral Component Interconnect)总线上的传输速率可达33MB/Sec。</p><p>2. SCSI (Small Computer Standard Interface)</p><p>SCSI是较高级(high level)的界面,可用于主机,磁盘,磁带,打印机等,因为是高阶的界面,规格较为复杂,一般自带控制器,也较为复杂,这就是SCSI磁盘为什么比IDE磁盘费的原因。但SCSI界面能较有效的利用硬件特性而提高其速度。其控制器还能对主机发给SCSI磁盘的命令进行缓冲、排队,并进行优化处理(命令队列)。现在较流行的是标准SCSI-2和SCSI-3。有两种规格,FAST SCSI(SCSI-2)的同步传输速率为10MB/Sec,数据传输宽度为8 bit, WIDE SCSI的数据传输宽度可达16-bit。Ultra SCSI(SCSI-3)的同步传输速率为20MB/Sec,Ultra Wide SCSI的同步传输速率为40MB/Sec,数据传输宽度可达32-bit。SCSI磁盘有虽有较高的传输速度,但受限于磁盘的存取速度及磁盘至SCSI界面的传输速度而不能充分发挥其性能(因为磁盘的机械动作难于有大幅度的改进);其命令分析程序(command phase)也较复杂。对单机来言，磁盘数量越多,主机找到特定的数据的时间越长,但对磁盘阵列来言,由于是多个磁盘一起并行处理,则表现为磁盘数量越多,速度越快。</p><p>以上界面的直接反应是单任务时IDE比SCSI快,多任务时SCSI较快,这可从用IDE盘和SCSI盘做多用户、多任务的操作系统(如UNIX、Windows/NT等)的系统盘时的启动时间的差别中明显看出。在单机时则不一定。我们看一个界面是否较快,不应只看其传崐输速度的高低而应就整个输入/输出的流程看,因为磁盘存取的机械动作比不上电脑的传输速率。IDE界面简单,反应快速,用于PC单机的小型的磁盘阵列其效果可能比SCSI为佳;但较大型的磁盘阵列就非SCSI界面莫属,因为阵列中的各个磁盘一起作存取的动作,能充分发挥SCSI的传输速率快及多工的特点。</p><p>此外IDE因为其配线规格的关系,不能作热插拔(hot swap),也就是不能在工作中带电插拔磁盘,而其线缆即使是增强型IDE也只有18寸,不能接在机箱之外,难于形成大的阵列,也就是只适用于PC低层次的用户。SCSI缆线在差分传输模式(differential transmission mode)下最大长度为25米,单端传输模式(single-ended transmission mode)时最大长度为6米,而一条SCSI总线可连接8台系统或各种不同的装置,扩充性很强,可形成很大的磁盘阵列空间;SCSI规格完备,容错能力很好,可带电插拔磁盘,是外接式装置无可取代的界面。</p><p>8. 磁盘阵列卡还是磁盘阵列控制器</p><p>磁盘阵列控制卡一般用于小系统，供单机使用。与主机共用电源，在关闭主机电源时存在丢失Cache中的数据的的危险。磁盘阵列控制卡只有常用总线方式的接口，其驱动程序与主机、主机所用的操作系统都有关系，有软、硬件兼容性问题并潜在地增加了系统的不安定因素。在更换磁盘阵列卡时要冒磁盘损坏，资料失落，随时停机的风险。</p><p>独立式磁盘阵列控制一般用于较大型系统,可分为两种：</p><p>单通道磁盘阵列和多通道式磁盘阵列，单通道磁盘阵列只能接一台主机，有很大的扩充限制。多通道磁盘阵列可接多个系统同时使用,以群集(cluster)的方式共用磁盘阵列,这使内接式阵列控制及单接式磁盘阵列无用武之地。DFT数据容错公司的DFTraid Rack Mount和DFTraid Tower等系统,都是独立形式的磁盘阵列子系统，其本身与主机系统的硬件及操作环境无关，只通过SCSI线缆与主机相接，主机把它当作一般的磁盘，所有的输出入动作都在磁盘阵列上完成，与主机的操作无关，所以可接任何可使用SCSI界面的主机。DFTraid Rack Mount和DFTraid Tower两系统最多可有六个SCSI通道，可同时连接5台主机;而DFTraid 5000系列则有9个通道,可同时连接多达8台主机，使之一起共用磁盘阵列子系统。这种方式的磁盘阵列既可给单机使用，又可给群集多机使用，对用户对增加阵列中的磁盘数量限制较小，并可用于备援及并行的容错电脑系统，特别适合较大的系统用户，使这些用户可从封闭的环境中解放出来。</p><p>9. RAID5建立过程</p><p>第一步：</p><p>[<img loading=lazy src=https://fastly.jsdelivr.net/gh/sethdang/sethPic/blog_img/3735172940950546770.jpg>](<a href=https://fastly.jsdelivr.net/gh/sethdang/sethPic/blog_img/5150429123851676322.jpg>https://fastly.jsdelivr.net/gh/sethdang/sethPic/blog_img/5150429123851676322.jpg</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://seth.dpdns.org/posts/cisco%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/><span class=title>«</span><br><span>cisco路由器的基本配置 </span></a><a class=next href=https://seth.dpdns.org/posts/%E5%87%86%E5%82%99%E5%8E%BB%E9%95%B7%E6%B2%99/><span class=title>»</span><br><span>准備去長沙</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 磁盘阵列(Disk Array)  on x" href="https://x.com/intent/tweet/?text=%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97%28Disk%20Array%29%20&amp;url=https%3a%2f%2fseth.dpdns.org%2fposts%2f%25E7%25A3%2581%25E7%259B%2598%25E9%2598%25B5%25E5%2588%2597disk-array%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 磁盘阵列(Disk Array)  on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fseth.dpdns.org%2fposts%2f%25E7%25A3%2581%25E7%259B%2598%25E9%2598%25B5%25E5%2588%2597disk-array%2f&amp;title=%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97%28Disk%20Array%29%20&amp;summary=%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97%28Disk%20Array%29%20&amp;source=https%3a%2f%2fseth.dpdns.org%2fposts%2f%25E7%25A3%2581%25E7%259B%2598%25E9%2598%25B5%25E5%2588%2597disk-array%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 磁盘阵列(Disk Array)  on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fseth.dpdns.org%2fposts%2f%25E7%25A3%2581%25E7%259B%2598%25E9%2598%25B5%25E5%2588%2597disk-array%2f&title=%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97%28Disk%20Array%29%20"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 磁盘阵列(Disk Array)  on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fseth.dpdns.org%2fposts%2f%25E7%25A3%2581%25E7%259B%2598%25E9%2598%25B5%25E5%2588%2597disk-array%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 磁盘阵列(Disk Array)  on whatsapp" href="https://api.whatsapp.com/send?text=%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97%28Disk%20Array%29%20%20-%20https%3a%2f%2fseth.dpdns.org%2fposts%2f%25E7%25A3%2581%25E7%259B%2598%25E9%2598%25B5%25E5%2588%2597disk-array%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 磁盘阵列(Disk Array)  on telegram" href="https://telegram.me/share/url?text=%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97%28Disk%20Array%29%20&amp;url=https%3a%2f%2fseth.dpdns.org%2fposts%2f%25E7%25A3%2581%25E7%259B%2598%25E9%2598%25B5%25E5%2588%2597disk-array%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 磁盘阵列(Disk Array)  on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97%28Disk%20Array%29%20&u=https%3a%2f%2fseth.dpdns.org%2fposts%2f%25E7%25A3%2581%25E7%259B%2598%25E9%2598%25B5%25E5%2588%2597disk-array%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://seth.dpdns.org/>Seth Dang'S</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>